# Paws PWA

This demo explains how to develop a Progressive Web App consuming grpc services.

It's based on grpc-web on backend exposing CRUD services using golang and mongodb. All the components of this demo are located in docker container and are managed by docker compose.

By using grpc and protobuf the size of transfered data will be 20 times smaller and almost 10 times faster (based on my own benchmarks) compared to traditional REST. 

## Server(less) backend:

GRPC nackend is written in go (golang). The code is located under server folder. Dependencies are handled by go modules and it used standard mongodb driver to communicate to database and exposes servies through google grpc and protobuf.

Proto is defines in server/pawsgrpc/paws_grpc.proto as following:

```

syntax = "proto3";

package paws.grpc;

import "google/protobuf/timestamp.proto";

service Paws {
  rpc CreateDiary (Diary) returns (ResultCode) {}

  rpc FetchAllDiaries (FetchParam) returns (DiaryList) {}
}

message Diary {
  string id = 1;
	string image = 2;
	string note = 3;
	google.protobuf.Timestamp date = 4;
}

// The response message containing the greetings
message DiaryList {
  repeated Diary diaries = 1;
}

message FetchParam {

}

message ResultCode {
    int32 code = 1;
}

```

For now there are only 2 simple calls (CreateDiary and FetchAllDiaries). In future we will use streaming and bidirectional communication.

### database access layer:

Database access logic is defined underserver/database folder. handler.go defines an interface and exposes database methods. mongo.go is mongodb implemetation if the interface. It simple implement data access methods to the pawsDB database.

excerpts from mongo.go:

```
import (
	"errors"
	"fmt"

	models "github.com/paws/server/model"
	"gopkg.in/mgo.v2"
)

// MongoHandler ...
type MongoHandler struct {
	*mgo.Session
}

// NewHandler ...
func NewHandler(config *models.Config) (*MongoHandler, error) {
	session, err := mgo.Dial(fmt.Sprintf("mongodb://%v:%v", config.Database.Host, config.Database.Port))
	handler := &MongoHandler{
		Session: session,
	}
	return handler, err
}

...
...
// FetchAllDiaries -
func (db *MongoHandler) FetchAllDiaries() ([]models.Diary, error) {
	session := db.getSession()
	defer session.Close()

	diaries := []models.Diary{}
	err := session.DB("pawsDB").C("diary").Find(nil).All(&diaries)

	return diaries, err

}
```
### Model

model/model.go contains the definition of the original database schema and object model plus config mode definition. we can break it to multiple files / structs when application grow. Keep in mind that until this layer our application is agnostic to proto and grpc so we won't be able to use the generated classes through protoc in database layer but we can map them later.

### Grpc 

server/pawsgrpc/paws_grpc.pb.go is go generated file through protoc. Basically the file has been generated by running following command:

```
protoc -I=$DIR paws_grpc.proto \
  --go_out=plugins=grpc:server/pawsgrpc
```

In server/pawsgrpc/grpc.go we convert grpc calls to database calls and map grpc objects to database objects :

```
func (srv *Runner) mapDiaries(diaries ...models.Diary) []*Diary {
	grpcDiaries := []*Diary{}
	for _, diary := range diaries {

		grpcDiaries = append(grpcDiaries, &Diary{
			Id:    diary.ID.Hex(),
			Date:  diary.DiaryDate,
			Image: diary.Image,
			Note:  diary.Note,
		})
	}
	return grpcDiaries
}
```
 
The rest of the server code is pretty straightforward. in main.go and runner.go we create config object and pass it grpc server and run the server.

